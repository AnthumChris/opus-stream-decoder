<html>
  <head>
    <title>Opus Stream SeekableDecoder Test</title>
    <style>
      body {
        background: #222;
        color: #ccc;
      }
    </style>
    <!-- <script src="opus-stream-decoder.js"></script> -->
  </head>
  <body>
    View output in browser console.
    <script>
      'use strict'

      // let request = new Request('http://localhost/1kbps/test-64kbps.opus')
      let request = new Request('http://localhost/nolimit/test-64kbps.opus')

      const seekableDecoder = new SeekableOpusStreamDecoder({request, initData: {}});
      seekableDecoder.ready.then(_ => console.log('decoder is ready'));

      function SeekableOpusStreamDecoder({request, headerSeekSize, headerSeekMax, initData}) {
        /* Ogg Page Header byte sequence

            0-3   "OggS" (1399285583)
            4     version
            5     flags
            6-13  granule
            14-17 serial
            18-21 page number
            22-25 crc checksum
            26    segments in page
            27+   segment table
         */

        // bytes required to read Ogg Page Header, we're reading up to page number
        const oggPageHeaderSize = 22;

        // little-endian "OggS" int32 value;
        const oggMagicNumber = 1399285583;

        this.request = request;

        if ('object' == typeof initData && ('headerPages', 'contentLength', 'duration') in initData) {
          this.headerBytes = initData.headerPages;
          this.contentLength = initData.contentLength;
          this.duration = initData.duration;
          this.ready = Promise.resolve();
        } else {
          this.ready = new Promise((resolve, reject) => {
            getInitData()
            .then(({headerPages, contentLength, duration}) => {
              this.headerBytes = headerPages;
              this.contentLength = contentLength;
              this.duration = duration;
              resolve();
            })
            .catch(err => {
              console.error('Error seeking initialization data', err);
            });
          });
        }

        /* returns Promise that resolves with {headerPages, size, duration}
             headers: Uint8array of first Ogg Opus page headers
             size: total bites of file/url
             duration: time in milliseconds of playback
         */
        function getInitData() {
          let headerPagesResolve,
              lastPageResolve;

          const headersPromise = fetchInitData(),
                lastPagePromise = new Promise(r => lastPageResolve = r);

          return headersPromise;
          // return Promise.all([headerPages, lastPage]);
        }


        // TODO handle case where servers don't support Range requests and entire file starts to download
        function fetchInitData() {
          const headerSeekRequest = request.clone(), // clone because we're modifying it
                headerSeekAbort = new AbortController(),  // cancels fetching after pages are found
                pageHeadersFound = [];  // once we find first two we're done

          headerSeekSize = headerSeekSize || 864*1;  // HTTP Range fetch interval size
          headerSeekMax = headerSeekMax || headerSeekSize*1; // stop fetching after this

          let totalHeaderBytesFetched = 0, // tracks total bytes fetched from server
              headerBytesFetched = new Uint8Array(0),
              contentLength = -1;          // file size obtained from Content-Range response header

          return new Promise((resolve, reject) => {
            return (function fetchHeaders() {
              const fetchSize = Math.min(headerSeekSize, headerSeekMax-totalHeaderBytesFetched);
              if (fetchSize <= 0) {
                throw new Error('Could not find Ogg Opus header pages within headerSeekMax '+headerSeekMax);
              }

              // increase read buffer by new fetch size
              headerBytesFetched = growTypedArray(headerBytesFetched, fetchSize);
              const headerDataView = new DataView(headerBytesFetched.buffer);

              headerSeekRequest.headers.set('Range', `bytes=${totalHeaderBytesFetched}-${totalHeaderBytesFetched+fetchSize-1}`)

              // TODO exit early on 416 Range not satisfiable (range > contentLength)
              return fetch(headerSeekRequest, {signal: headerSeekAbort.signal})
              .then(response => {
                // get contentLength after first response
                if (contentLength === -1) {
                  contentLength = parseContentLength(response);
                }

                const reader = response.body.getReader();
                return reader.read().then(function read({done, value}) {
                  if (done) return;

                  headerBytesFetched.set(value, totalHeaderBytesFetched);
                  totalHeaderBytesFetched += value.byteLength;

                  const seekStart = totalHeaderBytesFetched - value.byteLength;
                  const seekEnd = totalHeaderBytesFetched;
                  seekHeaderPages(pageHeadersFound, headerDataView, seekStart, seekEnd);

                  if (pageHeadersFound.length === 3) {
                    console.log(pageHeadersFound);
                    headerSeekAbort.abort();
                    resolve({
                      contentLength,
                      headerPages: headerBytesFetched.slice(0, pageHeadersFound[2].start)
                    })
                  }

                  return reader.read().then(read);
                })
              })
              .then(fetchHeaders)
              .catch(err => {
                // AbortError is intentional, throw other errors
                if (err.name !== 'AbortError')
                  reject(err);
              })
            })()
          });
        }

        // find header page boundaries and add to pagesFound
        function seekHeaderPages(pagesFound, dataView, offset, end) {
          // rewind by oggPageHeaderSize to complete previous unread bytes
          offset = Math.max(0, offset-oggPageHeaderSize);

          // require oggPageHeaderSize bytes to read Ogg page header
          while (offset < end - oggPageHeaderSize) {
            if (dataView.getUint32(offset, true) === oggMagicNumber) {
              pagesFound.push(new OggPageHeader(dataView, offset));

              // we're done if we found 3 pages
              if (pagesFound.length === 3) return;

              offset+=28; // fast forward through found header
            } else {
              offset++;
            }
          }
        }

        // Parses file size from Content-Range header (e.g. 'bytes 0-1024/56000');
        function parseContentLength(response) {
          const rangeHeader = response.headers.get('Content-Range');
          if (!rangeHeader)
            throw Error('Content-Range header not returned by server. Access-Control-Expose-Headers configured?');

          try {
            let contentLength = parseInt(rangeHeader.match(/bytes .*\/([\d]+)/)[1]);
            if (isNaN(contentLength)) throw Error('parsed contentLength is NaN');
            return contentLength;
          } catch (e) {
            console.error(e);
            throw Error('Could not parse file size from Content-Range header');
          }
        }
      }

      function growTypedArray(array, growSize) {
        const newArray = new array.constructor(array.byteLength+growSize);
        newArray.set(array);
        return newArray;
      }

      function OggPageHeader(view, viewOffset) {

        this.start = viewOffset;
        this.flags = view.getUint8(viewOffset+5, true);
        this.granule = view.getUint32(viewOffset+6, true);

        // TODO this is probably not needed
        this.page = view.getUint32(viewOffset+18, true);

        // TODO is this still needed? perhaps for more accurate duration seeking
        // const totalSegments = view.getUint8(viewOffset+26, true);
        // this.segments = [];
        // for (let i=0; i<totalSegments; i++) {
        //   this.segments.push(view.getUint8(viewOffset+27+i, true));
        // }
      }

    </script>
  </body>
</html>