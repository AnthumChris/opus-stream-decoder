<html>
  <head>
    <title>Opus Stream SeekableDecoder Test</title>
    <style>
      body {
        background: #222;
        color: #ccc;
      }
    </style>
    <!-- <script src="opus-stream-decoder.js"></script> -->
  </head>
  <body>
    View output in browser console.
    <script>
      'use strict'

      // let request = new Request('http://localhost/1kbps/test-64kbps.opus')
      let request = new Request('http://localhost/nolimit/test-64kbps.opus')

      const seekableDecoder = new SeekableOpusStreamDecoder({request, initData: {}});
      seekableDecoder.ready.then(_ => console.log('decoder is ready'));

      function SeekableOpusStreamDecoder({request, initData, headerSeekSize, headerSeekMax, durationSeekSize, durationSeekMax}) {
        /* Ogg Page Header byte sequence

            0-3   "OggS" (1399285583)
            4     version
            5     flags
            6-13  granule
            14-17 serial
            18-21 page number
            22-25 crc checksum
            26    segments in page
            27+   segment table
         */

        // bytes required to read Ogg Page Header, we're reading up to page number
        const oggPageHeaderSize = 22;

        // little-endian "OggS" int32 value;
        const oggMagicNumber = 1399285583;

        this.request = request;

        if ('object' == typeof initData && ('headerPages', 'contentLength', 'duration') in initData) {
          this.headerBytes = initData.headerPages;
          this.contentLength = initData.contentLength;
          this.duration = initData.duration;
          this.ready = Promise.resolve();
        } else {
          this.ready = new Promise((resolve, reject) => {
            fetchInitData()
            .then(({headerPages, contentLength, duration}) => {
              this.headerBytes = headerPages;
              this.contentLength = contentLength;
              this.duration = duration;
              resolve();
            })
            .catch(err => {
              console.error('Error seeking initialization data', err);
            });
          });
        }

        /* returns Promise that resolves with {headerPages, size, duration}
             headers: Uint8array of first Ogg Opus page headers
             size: total bites of file/url
             duration: time in milliseconds of playback
         */
        // TODO handle case where servers don't support Range requests and entire file starts to download
        function fetchInitData() {
          // clone requests because we're modifying them
          const headerSeekRequest = request.clone();

          const headerSeekAbort = new AbortController(),  // cancels fetching after pages are found
                pageHeadersFound = [];  // list of page headers found

          // Set default values for Range requests if not provided
          headerSeekSize = headerSeekSize || 1024*1;
          headerSeekMax = headerSeekMax || headerSeekSize*8;

          let totalHeaderBytesFetched = 0, // tracks total bytes fetched from server
              headerBytesFetched = new Uint8Array(0),
              lastPagePromise, // instantiated after contentLength found
              contentLength = -1;          // file size obtained from Content-Range response header

          return new Promise((resolve, reject) => {
            return (function fetchHeaders() {
              const fetchSize = Math.min(headerSeekSize, headerSeekMax-totalHeaderBytesFetched);
              if (fetchSize <= 0) {
                throw new Error('Could not find Ogg Opus header pages within headerSeekMax '+headerSeekMax);
              }

              // increase read buffer by new fetch size
              headerBytesFetched = growTypedArray(headerBytesFetched, fetchSize);
              const headerDataView = new DataView(headerBytesFetched.buffer);

              headerSeekRequest.headers.set('Range', `bytes=${totalHeaderBytesFetched}-${totalHeaderBytesFetched+fetchSize-1}`)

              // TODO exit early on 416 Range not satisfiable (range > contentLength)
              return fetch(headerSeekRequest, {signal: headerSeekAbort.signal})
              .then(response => {
                // get contentLength after first response
                if (contentLength === -1) {
                  contentLength = parseContentLength(response);
                  lastPagePromise = fetchLastPage(contentLength);
                }

                const reader = response.body.getReader();
                return reader.read().then(function read({done, value}) {
                  if (done) return;

                  headerBytesFetched.set(value, totalHeaderBytesFetched);
                  totalHeaderBytesFetched += value.byteLength;

                  // rewind by oggPageHeaderSize to complete previous unread bytes
                  const seekStart = Math.max(0, totalHeaderBytesFetched - value.byteLength - oggPageHeaderSize);

                  const headers = findOggPageHeaders(headerDataView, seekStart, totalHeaderBytesFetched, seekStart, 3-pageHeadersFound.length);
                  pageHeadersFound.push(...headers);

                  if (pageHeadersFound.length === 3) {
                    headerSeekAbort.abort();
                    resolve({
                      contentLength,
                      headerPages: headerBytesFetched.slice(0, pageHeadersFound[2].start)
                    })
                  }

                  return reader.read().then(read);
                })
              })
              .then(fetchHeaders)
              .catch(err => {
                // AbortError is intentional, throw other errors
                if (err.name !== 'AbortError')
                  reject(err);
              })
            })()
          })
          .then(({contentLength, headerPages}) => {
            return lastPagePromise
            .then(lastPage => {

              const duration = -1;
              return {contentLength, headerPages, duration};
            });
          })

          /* last page's granule position is used to calculate duration
           * fetch in chuncks from the end of the file until the last Ogg page is found
           */
          function fetchLastPage(contentLength) {
            const durationRequest = request.clone();

            durationSeekSize = durationSeekSize || 1024*1;
            durationSeekMax = durationSeekMax || 1024*64; // max Ogg Page size

            return new Promise(resolve => {
              // left boundary of range from end of file
              const leftBoundary = Math.max(contentLength-1-durationSeekMax, 0);

              let readBuffer = new Uint8Array(0),
                  rangeEnd = contentLength-1; // decrease this with each fetch()

              return (function fetchFromEnd() {
                if (rangeEnd <= leftBoundary) {
                  throw new Error('Could not find last Ogg Opus page within durationSeekMax '+durationSeekMax);
                }

                const rangeStart = Math.max(rangeEnd-durationSeekSize+1, leftBoundary, 0);
                durationRequest.headers.set('Range', `bytes=${rangeStart}-${rangeEnd}`);
                console.log('Range', durationRequest.headers.get('range'), 'size', rangeEnd-rangeStart+1);

                let totalBytesFetched = 0;

                return fetch(durationRequest)
                .then(resp => resp.arrayBuffer())
                .then(buffer => {
                  // use first bytes from last fetch readBuffer to complete buffer's scan of oggPageHeaderSize
                  const endBytes = readBuffer.slice(0, oggPageHeaderSize-1);
                  readBuffer = new Uint8Array(buffer.byteLength + endBytes.byteLength);
                  readBuffer.set(new Uint8Array(buffer));
                  readBuffer.set(endBytes, buffer.byteLength);
                  const pagesFound = findOggPageHeaders(new DataView(readBuffer.buffer), 0, readBuffer.byteLength, rangeStart);

                  // resolve with last page found
                  if (pagesFound.length) {
                    return resolve(pagesFound.pop());
                  }

                  // set new range and repeat
                  rangeEnd-= buffer.byteLength;
                  return fetchFromEnd();
                });

              })()
            });
          }
        }

        // returns an array of all Ogg Page headers found within dataView
        function findOggPageHeaders(dataView, dataOffset, dataLen, fileStartPos, stopAfter) {
          const headers = [];

          // require oggPageHeaderSize bytes to read Ogg page header
          let startOffset = dataOffset;
          while (dataOffset < dataLen - oggPageHeaderSize) {
            if (dataView.getUint32(dataOffset, true) === oggMagicNumber) {
              const header = new OggPageHeader(dataView, dataOffset, fileStartPos+dataOffset-startOffset);
              console.log('Ogg page found:', header);
              headers.push(header);

              // we're done if we found 3 pages
              if (stopAfter && headers.length === stopAfter) break;

              dataOffset+=28; // fast forward through found header
            } else {
              dataOffset++;
            }
          }

          return headers;
        }

        // Parses file size from Content-Range header (e.g. 'bytes 0-1024/56000');
        function parseContentLength(response) {
          const rangeHeader = response.headers.get('Content-Range');
          if (!rangeHeader)
            throw Error('Content-Range header not returned by server. Access-Control-Expose-Headers configured?');

          try {
            let contentLength = parseInt(rangeHeader.match(/bytes .*\/([\d]+)/)[1]);
            if (isNaN(contentLength)) throw Error('parsed contentLength is NaN');
            return contentLength;
          } catch (e) {
            console.error(e);
            throw Error('Could not parse file size from Content-Range header');
          }
        }
      }

      function growTypedArray(array, growSize) {
        const newArray = new array.constructor(array.byteLength+growSize);
        newArray.set(array);
        return newArray;
      }

      function OggPageHeader(view, viewOffset, posFromFileStart) {
        this.filePos = posFromFileStart;
        this.filePosHex = posFromFileStart.toString(16); // used for debugging
        this.granule = view.getUint32(viewOffset+6, true);
        this.serial = view.getUint32(viewOffset+14, true);
        this.page = view.getUint32(viewOffset+18, true);
        this.flags = view.getUint8(viewOffset+5, true);

        // TODO is this still needed? perhaps for more accurate duration seeking
        // const totalSegments = view.getUint8(viewOffset+26, true);
        // this.segments = [];
        // for (let i=0; i<totalSegments; i++) {
        //   this.segments.push(view.getUint8(viewOffset+27+i, true));
        // }
      }

      // parses ID header and returns info per https://tools.ietf.org/html/rfc7845.html#section-5.1
      function parseIdHeader(oggPageHeader) {

      }
    </script>
  </body>
</html>